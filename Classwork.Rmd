---
title: "Classwork1"
author: "Elizabeth Daniela Monsalve Forero"
date: "2023-08-18"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Loading the libraries

```{r message = FALSE}
library(nycflights13)
library(tidyverse)
```

In this step, the nycflights13 library is loaded, which contains flight-related datasets and the tidyverse library, which is a collection of related packages that facilitate data management and analysis.

## 5.2.4 Exercises: items 1, and 2

```{r}
flights_d <- nycflights13::flights

Delay2 <- filter(flights_d,arr_delay >="120")

F_HOU <- filter(flights_d,dest =="HOU")
```

In the first line of code it loads the flights dataset from the nycflights13 package into the flights_d variable. This creates a data frame containing information about flights.

Subsequently, the filter() function of the dplyr package is used to filter the flights_d data frame. The function arr_delay >= "120" filters out flights that have an arrival delay of at least 2 hours (120 minutes) and is stored in a variable called Delay2.

```{r}
library(knitr)
kable(Delay2[1:10,c(11,12,9)],caption= "DELAYED FLIGHTS", align = "c")
```

Again, the filter() function is used to filter the flights_d data frame. An object called F_HOU is created which will contain the flights with destination (dest) to the airport with the three-letter code "HOU" (Houston).

```{r}
library(knitr)
kable(F_HOU[1:10,c(11,12,14)],caption= "DESTINATION HOUSTON", align = "c")
```


## 5.3.1 Excercises: all items

### 1

```{r}
missing_flights_sorted  <- flights %>%
  arrange(desc(is.na(dep_time)))
```

The original flights dataset is taken and the operator is used and the arrange(desc(desc(is.na(dep_time))) function is used, which sorts the data frame in descending order (desc()) based on whether the output time (dep_time) is missing or not (is.na(dep_time)). This places rows with absent dep_time values at the beginning of the data frame, while rows with present values are placed after.

```{r}
library(knitr)
kable(missing_flights_sorted[1:10,c(11,12,4)],caption= "MISSING FLIGHTS STORTED", align = "c")
```

### 2

```{r}
most_delayed <- flights %>%
  arrange(desc(arr_delay))
```

The arrange(desc(arr_delay)) function is used, which sorts the data frame based on the arrival delay (arr_delay) in descending order. This places the flights with the longest delays at the beginning.

```{r}
library(knitr)
kable(most_delayed[1:10,c(11,12,9)],caption= "MOST DELAYED FLIGHT", align = "c")
```

### 3

```{r}
fastest_flights <- flights %>%
  mutate(speed = distance / air_time) %>%
  arrange(desc(speed))
```

In this line, first, use mutate() to add a new column named speed representing the speed of the flight (distance / time in the air). Then, you use the arrange(desc(speed)) function to sort the data frame based on the speed column in descending order. This places the fastest flights at the top.

```{r}
library(knitr)
kable(fastest_flights[1:10,c(11,12,20)],caption= "FASTEST FLIGHT", align = "c")
```

### 4

```{r}
farthest_flights <- flights %>%
  arrange(desc(distance))
```

Using the arrange(desc(distance)) function, the data frame is sorted based on the distance of the flight in descending order. This places the longest flights at the top.

```{r}
library(knitr)
kable(farthest_flights[1:10,c(11,12,16)],caption= "FARTHEST FLIGHT", align = "c")
```

```{r}
shortest_flights <- flights %>%
  arrange(distance)
```

With the arrange(distance) function, the data frame is sorted according to the distance of the flight in ascending order. This places the shortest flights at the beginning.

```{r}
library(knitr)
kable(shortest_flights[1:10,c(11,12,16)],caption= "SHORTEST FLIGHT", align = "c")
```

## 5.4.1 Exercises: items 2, 3, and 4

### 2 What happens if you include the name of a variable multiple times in a select() call?

```{r}
v2<- select (flights, year, month, day, dep_time, dep_time)
library(knitr)
kable(v2[1:10,],caption= "DUPLICATED VARIABLE")
```

After generating the table we confirm that the software just skips over the repeated variable, since departure time was only displayed once.

### 3a What does the any_of() function do? 

It allows to select variables from character vectors, like that of all_of. What any_of does is look at variables contained in a character vector without checking for missing variables.

### 3b Why might it be helpful in conjunction with this vector?

```{r}
variables <- c("year", "month", "day", "dep_delay", "arr_delay")
vars<-select(flights, any_of(variables))
library(knitr)
kable(vars[1:10,],caption= "VARIABLES")
```

The any_of() function is useful because it avoids the need to have to constantly retype variable names each time they are applied. By creating a vector that is able to rationalize the variables in an easy and consistent manner

### 4a Does the result of running the following code surprise you?

```{r}
time <- select(flights, contains("TIME"))
library(knitr)
kable(time[1:10,])
```

Contains("TIME") is a function that is used as an argument inside select to specify that all columns containing the string "TIME" in their names should be selected, thus generating a table composed of variables that share a common characteristic in a simple and fast way.

### 4b How do the select helpers deal with case by default?

The contains() function can be used to ensure that all the variables belonging to the same category are taken automatically, quickly, and avoiding human errors that may not take any variable into account in a study.

### 4c  How can you change that default?

```{r}
default<-select(flights, contains("TIME", ignore.case = FALSE))
library(knitr)
kable(default[1:10,])
```

In this case, contains("TIME", ignore.case = FALSE) is an argument within the function that specifies that all columns whose names contain the character string "TIME" in its exact form should be selected, without ignoring case differences. 

## 5.5.2 Exercises: items 1, and 2

### 1 Currently dep_time and sched_dep_time are convenient to look at, but hard to compute with because they’re not really continuous numbers. Convert them to a more convenient representation of number of minutes since midnight.

```{r}
minutes_since_midnight<-transmute(flights,deptime = dep_time/60, schedeptime=sched_dep_time/60)
library(knitr)
kable(minutes_since_midnight[1:10,])
```

Transmute is a function used to create new columns or modify existing columns in a dataframe. In this case, two new columns are being created:

deptime = dep_time/60: A column called deptime is created containing the values of the dep_time column (representing the departure time in HHMM format), divided by 60 to convert them to minutes since midnight. This will give you the number of minutes elapsed from midnight to the departure time.

schedeptime = sched_dep_time/60: A column called schedeptime is created containing the values of the sched_dep_time column (representing the scheduled departure time in HHMM format), also divided by 60 to convert them to minutes since midnight. This will give you the number of minutes elapsed from midnight to the scheduled departure time.

### 2 Compare air_time with arr_time - dep_time. What do you expect to see? What do you see? What do you need to do to fix it?

```{r}
function1<-flights %>% 
mutate(dep_time = (dep_time %/% 100) * 60 + (dep_time %% 100),
         sched_dep_time = (sched_dep_time %/% 100) * 60 + (sched_dep_time %% 100),
         arr_time = (arr_time %/% 100) * 60 + (arr_time %% 100),
         sched_arr_time = (sched_arr_time %/% 100) * 60 + (sched_arr_time %% 100)) %>%
transmute((arr_time - dep_time) %% (60*24) - air_time)
```

The mutate function is used to create or modify columns in the dataframe, in this case the formula is used:

¨variable" = (¨variable" %/% 100) * 60 + (¨variable" %% 100): in which an operation is performed to convert the variable time in HHMM format, resulting in 3 new variables: actual departure time (dep_time),scheduled departure time (sched_dep_time), actual arrival time (arr_time), scheduled arrival time (sched_arr_time).

After the above transformation using mutate, the transmute function is chained. It calculates the difference in minutes between the actual arrival time (arr_time) and the actual departure time (dep_time). Then, the operation modulo (arr_time - dep_time) %% (60*24) is applied to obtain the difference in minutes considering a cycle of 24 hours. Finally, the flight time (air_time) is subtracted from this difference.

```{r}
library(knitr)
kable(function1[1:10,])
```

## 5.6.7 Exercises: item 1

### Brainstorm at least 5 different ways to assess the typical delay characteristics of a group of flights. Consider the following scenarios:

A flight is 15 minutes early 50% of the time, and 15 minutes late 50% of the time.

A flight is always 10 minutes late.

A flight is 30 minutes early 50% of the time, and 30 minutes late 50% of the time.

99% of the time a flight is on time. 1% of the time it’s 2 hours late.

```{r}
fifteen_early <- flights %>%
  filter(arr_delay == -15, na.rm = TRUE)
library(knitr)
kable(fifteen_early[1:10,c(11,12,9)], align = "c")

fifteen_late <- flights %>%
  filter(arr_delay == 15, na.rm = TRUE)
library(knitr)
kable(fifteen_late[1:10,c(11,12,9)], align = "c")

ten_always <- flights %>%
  filter(arr_delay == 10, na.rm = TRUE)
library(knitr)
kable(ten_always[1:10,c(11,12,9)], align = "c")

thirty_early <- flights %>%
  filter(arr_delay == -30, na.rm = TRUE)
library(knitr)
kable(thirty_early[1:10,c(11,12,9)], align = "c")

thirty_late <- flights %>%
  filter(arr_delay == 30, na.rm = TRUE)
library(knitr)
kable(thirty_late[1:10,c(11,12,9)], align = "c")

percentage_on_time <- flights %>%
  filter(arr_delay == 0, na.rm = TRUE)
library(knitr)
kable(percentage_on_time[1:10,c(11,12,9)], align = "c")

two_hours  <- flights %>%
  filter(arr_delay > 120, na.rm = TRUE)
library(knitr)
kable(two_hours[1:10,c(11,12,9)], align = "c")
```
fifteen_early <- flights %>% filter(arr_delay == -15, na.rm = TRUE): In this block, the observations of the flights dataset are filtered to create a new dataset called fifteen_early. Only the observations where the arrival delay (arr_delay) is equal to -15 are selected, and na.rm = TRUE is used to exclude the observations with values that do not apply. 

Similarly, the other data subsets are created:

fifteen_late: contains the flights with arrival delay equal to 15.
ten_always: Contains the flights with arrival delay equal to 10.
thirty_early: Contains flights with arrival delay equal to -30.
thirty_late: Contains flights with arrival delay equal to 30.
percentage_on_time: Contains flights with arrival delay equal to 0 (i.e. flights that arrived on time).
two_hours: Contains flights with arrival delay greater than 120 (i.e. flights with a delay of more than 2 hours).
## 5.6.8

```{r}
    worst_punctuality <- flights %>%
      group_by(tailnum) %>%
      summarize(
        total_flights = n(),
        punctual_flights = sum(arr_delay <= 0, na.rm = TRUE),
        punctuality_percentage = (punctual_flights / total_flights) * 100
      ) %>%
      arrange(punctuality_percentage) %>%
      filter(!is.na(punctuality_percentage))
library(knitr)
kable(worst_punctuality[1:10,])
```

worst_punctuality <- flights: Start taking the original flights dataset.

group_by(tailnum): Groups the observations by the tail number of the aircraft (tailnum). 

summarize(...): For each group of flights (aircraft) the following calculations are performed:

total_flights: Calculates the total number of flights associated with the aircraft.
punctual_flights: Calculates the number of flights that were punctual or arrived on time (defined as those with an arrival delay equal to or less than 0).
punctuality_percentage: Calculates the percentage of on-time flights relative to the total number of flights on the aircraft, multiplied by 100 to get a percentage.
arrange(punctuality_percentage): After calculating the metrics the results are sorted in ascending order by punctuality percentage. This means that the planes with the worst punctuality will be at the top.
